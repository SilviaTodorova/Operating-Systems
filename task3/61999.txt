Документация:
Решението на задачата се основава на алгоритъма за двойчно търсете. Първият подаден параметър е името на речника, а вторият е думата, която търсим в него. Ако намерим думата, извеждаме нейното значение, в противен случай извеждаме, че такава дума не съществува в речника. 

Изпълнението на програмата започва от главната функцията, в която като първа стъпка проверяваме дали броя на аргументите е коректен. След това се опитваме да отворим файла. Ако тези две проверки преминат успешно, преминаваме към съществената част на задачата.

В променливата word записваме думата, която търсим в речника. С функцията lseek променяме указателя във файла. Всяка дума се определя от нулев символ ('\0'), който идентифицира началото на думата, един или повече символи (самата дума) и символ за нов ред ('\n').

Поставяме указателя на първа позиция, за да прескочим нулевия символ и четем до нов ред с функцията read_to_symbol. Взимаме първата и последната дума от файла и проверяваме дали те не са търсената дума, ако имаме съвпадение, директно извеждаме значението на думата. В противен случай търсим в целия файл. 

Ако думата е по-малка или по-голяма (лексикографско сравняване) от първата или от последната дума в речника, извеждаме, че такава дума не съществува. При двойчното търсене, размерът на претърсваното пространство намалява на половина след всяка итерация. Намираме коя е думата между долната и горната граница, сравняваме я с търсената дума и ако те са равни, значи сме я открили и извеждаме нейното значение, ако е по-малка, търсим в първата половина или ако е по-голяма, търсим съответно във втората половина. Важна стъпка е да си определим долната и горната граница, тоест откъде докъде търсим във файла. Ако думата е в първата половина трябва да променим горната граница, а ако се окаже, че е във втората, трябва да променим долната граница. След това отново разделяме двете области, сравняваме, променяме горната или долната граница и т.н. докато не открием търсената дума. Реализацията за файлове е по-сложна от реализацията за масиви, тъй като взимането на средната дума, спрямо долната и горната граница, не е като взимането на средния елемент по индекс в масив. В тази ситуация, за да намерим средната дума преместваме указателя в края на файла и в променливата n, записваме неговия размерът, делим на две, за да разберем къде е срeдата на файла и преместваме там указателя чрез функцията lseek и флага SEEK_SET. Но тъй като средата на файла, не означава началото на средната дума, а може указателят да е някъде из реда, трябва да го преместим назад до началото на думата. В нашия случай до нулев символ, защото преди всяка дума в речника има такъв. След като сме преместили указателя, отново с функцията read_to_symbol четем от файла до нов ред. Тези две стъпки са обединени във функцията get_word.

Функции:
read_to_symbol - основна функция, която ни позволява да четем символ по символ от файла докато стигнем до разделителя, подаден като втори параметър. Функцията връща указател от тип char*. Заделяме динамично памет и проверяваме дали заделянето е било успешно. След това четем символ по символ, ако имаме нужда от повече място в масива използваме системната функция realloc като освен масива и подаваме променливата size, която преди това сме умножили по 2. 
Преди функцията read_to_symbol да върне масива, добавяме символ за край на стринг.
 
move_to_null - използваме я, за да върнем указателя на файла до нулев символ, в нашия случай до начало на дума. Четем символ по символ и на всяка стъпка проверяваме текущия символ, ако той е различен от '\0' продължаваме, в противен случай излизаме от функцията. Тъй като е от тип void, не връщаме нищо, идеята и е само да преместим указателя.

print_str 
Изписва стринга подаден като единствен параметър на функцията на стандартния
изход. Използваме вградената функция strlen, която ни дава дължината на
стринга. Ако възникне проблем при писането, функцията връща -1.

В цялата програма са разгледани случаите, при който може да възникни грешка при извикването на системните функции. Заделената памет бива освободена и всички файлови дескриптори биват затворени преди приключването на програмата.

Използвани библиотеки:
#include <err.h> - err, errx
#include <errno.h> - глобалната променлива errno
#include <fcntl.h> - open 
#include <unistd.h> - lseek
#include <stdlib.h> - malloc, realloc, free
#include <string.h> - strcmp

Документация:

Първата стъпка е да направим проверка за броя на аргументите. Програмата трябва да приема един аргумент, цяло число, максималния брой паралелни задачи. 

Функцията convert проверява дали подадения аргумен е валиден, тоест дали се състои само от цифри и ако е така го преобразува в цяло число с функцията atoi.

Функцията read_line използва динамично заделяне на памет. Заделяме толкова памет колкото е максималната дължина на реда. Максималната дължина на реда е изведена в глобалната константа ARG_MAX. Във функцията четем символ по символ от стандартния вход докато снигнем до символ за нов ред, ако не успеем да прочетем дадения символ освобождаваме заделената памет, извеждаме подходящо съобщение за това и програмата приключва. Всеки ред бива подаден на функцията parallel_execution. Функцията execute_line ни осигурява правилното изпълнение на всеки ред от команди, последователно или паралелно, взависимост от знака между тях. 

Във функцията execute_line разделяме реда спрямо ';' и записваме командите в масив. След това изпълняваме всяка една команда последователно. Може да имаме и по-сложни конструкции като pipeline, но не и multiple pipe. Ако имаме единична команда, я изпълняваме с execute_single_command, ако имаме pipeline с едноименната команда.

Функцията pipeline работи само с две команди, не изпълнява mulitiple pipe. Ако на програмата бъде подаден такъв, извеждаме подходящо съобщение за това и програмата терминира. Направени са проверки дали системните извиквания са изпълнение успешно. Във функцията pipeline детето изпълнява първата команда, като пише в споделения ресурс, тръбата, а бащата чете от него и изпълнява втората команда. 

Функцията split приема три параметъра: реда, който трябва да разделим, масива, в който ще се намират разделените символни низове и разделителя. При първото извикване на функцията strtok трябва да бъде подаден низът, който искаме да разделим. При всяко следващо извикване, подаваме NULL. Strtok връща указател към стринг, който е null-terminated и съдържа следващия разделител. Ако не бъдат намерени повече символи, strtok връща NULL. Така на всяка итерация се добавя по един стринг в масива (args). 

char *strtok(char *str, const char *delim);
При извикването на функцията strtok имаме няколко ограничения. Като например, че функцията променя първия си параметър, именно поради тази причина не може да и подадем константен указател. Затова използваме помощните масиви (tmp_cmd, tmp_left, tmp_right). 

Глобалният масив, whitespace съдържа само символите за интервал и табулация. При необходимост могат лесно да бъдат добавени нови разделите, като това по никакъв начин няма да промени логиката на задачата.

Функцията parallel_execition осигурава паралелизва в задачата. При всяко нейно извикване се създава нов процес, в който изпълняваме съответния ред. Когато имаме толкова на брой задачи, колкото е максималния брой, тогава изчакаме поне едно дете да завърши.

waitpid(-1,NULL,WNOHANG) - връща число по-голямо от единица, кога се промени състоянието на някое от децата и съответно, когато това стане -  намаляваме броя на задачите, които се изпълняват. Така във всеки един момент от времето в променливата tasks се пази броя на изпълняваните задачи.
